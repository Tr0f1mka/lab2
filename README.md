<h1> Лабораторная работа №2 "Мини-оболочка с файловыми командами" </h1>
<hr>
<p>Оболочка для работы с файлами(просмотр, перемещение, удаление и т. д.). Были реализованы функции из модуля Easy, а также функции для работы с архивами zip и tar.gz</p>

<p>Поддерживает следующие команды:</p>
<ul>
    <li>"ls" - выводит содержимое директории </li>
    <li>"cd" - переходит в указанную директорию </li>
    <li>"cat" - выводит содержимое файла </li>
    <li>"cp" - копирует файл/директорию в назначение </li>
    <li>"mv" - переносит файл/директорию в назначение </li>
    <li>"rm" - удаляет файл/директорию </li>
    <li>"zip" - создаёт архив zip </li>
    <li>"unzip" - распаковывает архив zip в рабочую директорию </li>
    <li>"tar" - создаёт архив tar.gz </li>
    <li>"untar" - распаковывает архив tar.gz в рабочую директорию </li>
    <li>"help" - выводит справку по функциям </li>
    <li>"exit" - завершает работу программы </li>
</ul>

<p2> Структура </p2>
<pre>
    .
    ├── lab2
    │   ├── src/                               # Папка с кодом
    │       ├── __init__.py                    #
    |       ├── archive_funcs.py               # Функции для работы с архивами
    │       ├── check_input.py                 # Функции парсера и нормализации пути
    │       ├── config.py                      # Конфигурация для логера
    │       ├── format_funcs.py                # Функции, форматирующие файлы/каталоги(копирование, перемещение, удаление)
    │       ├── main.py                        # Точка входа
    │       ├── patterns.py                    # Шаблоны
    |       ├── read_funcs.py                  # Функции, читающие файлы/каталоги, а также функция перехода
    │   ├── tests/                             # Юниттесы
    |       ├── __init__.py                    #
    │       ├── test_archive_funcs.py          # Тест архивных функций
    │       ├── test_check_input.py            # Тест парсера и нормализации пути
    │       ├── test_format_funcs.py           # Тест форматирующих функций
    │       ├── test_read_funcs.py             # Тест читающих функций
    │   ├── .gitignore                         # Файл, который не даёт мусорить в гите
    │   ├── .pre-commit-config.yaml            # Конфигурация любимого pre-commit
    |   ├── pyproject.toml                     # Информация по проекту(для системы)
    |   ├── README.md                          # Документация
    │   ├── requirements.txt                   # Зависимости проекта
    |   ├── uv.lock                            # зависимости проекта
</pre>

<h2> Описание модулей </h2>
<ul>
     <li>main.py - входная точка программы. Содержит функции вывода сообщений, через неё пользователь взаимодействует с программой </li>
     <li>check_input.py - модуль, который содержит функции парсера и преобразования пути в абсолютный </li>
     <li>read_funcs.py - модуль с функциями ls, cd, cat </li>
     <li>format_funcs.py - модуль с функциями cp, mv, rm </li>
     <li>archive_funcs.py - модуль с функциями zip, unzip, tar, untar </li>
     <li>patterns.py - содержит шаблоны регулярных выражений для остальных модулей. </li>
</ul>

<h2> Алгоритм ls </h2>
    <p>Переходим в текущую рабочую директорию. Проверяем, что флагов нет или есть только "-l". Затем проверяем пути: если они есть - возвращаем их абсолютные пути, иначе - используем путь рабочей директории. Затем выводим содержимое директорий: если есть флаг - получаем размер, время последнего изменения и права файлов/директорий, затем выводим их вместе с названиями, иначе выводим только названия файлов/директорий. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм cd </h2>
    <p>Переходим в текущую рабочую директорию. Если есть 1 путь - используем его абсолютную версию, иначе выдаём ошибку. Затем пытаемся перейти в указанную директорию. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм cat </h2>
    <p>Переходим в текущую рабочую директорию. Если есть пути - получаем их абсолютные версии, иначе - ошибка. Дальше пытаемся открыть файлы, считать их и вывести. Если файла нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм cp </h2>
    <p>Переходим в текущую рабочую директорию. Проверяем флаги: если пустой или "-r" - продолжаем, иначе ошибка. Проверка путей: если их 2 - возвращаем их абсолютные версии, иначе - ошибка. Если флаг пустой - пытаемся копировать файл из первого пути в директорию второго пути. Иначе(флаг -r) - пытаемся копировать директорию из первого пути в директорию второго пути. Если файла/директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм mv </h2>
    <p>Переходим в текущую рабочую директорию. Проверка путей: если их 2 - возвращаем их абсолютные версии, иначе - ошибка. Пытаемся перенести файл/директорию в назначение. Если файла/директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм rm </h2>
    <p>Переходим в текущую рабочую директорию. Проверяем флаги: если пустой или "-r" - продолжаем, иначе ошибка. Если есть пути - получаем их абсолютные версии, иначе - ошибка. Если флаг пустой - пытаемся удалить каждый файл, прося разрешение. Иначе(флаг -r) - проверяем, что удаляемая директория не корень и не с верхних уровней, затем с разрешения пользователя пытаемся удалить каждую директорию. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм zip </h2>
    <p>Переходим в текущую рабочую директорию. Проверка путей: если их 2 - возвращаем их абсолютные версии, иначе - ошибка. Пытаемся архивнуть директорию в назначение. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм unzip </h2>
    <p>Переходим в текущую рабочую директорию. Проверка путей: если он 1 - возвращаем его абсолютную версию, иначе - ошибка. Пытаемся разархивнуть директорию в рабочую директорию. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм tar </h2>
    <p>Переходим в текущую рабочую директорию. Проверка путей: если их 2 - возвращаем их абсолютные версии, иначе - ошибка. Пытаемся архивнуть директорию в назначение. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм untar </h2>
    <p>Переходим в текущую рабочую директорию. Проверка путей: если он 1 - возвращаем его абсолютную версию, иначе - ошибка. Пытаемся разархивнуть директорию в рабочую директорию. Если директории нет/нет прав/что-то с ОС - выводим соответствующую ошибку. Результат записывается в лог-файл.</p>

<h2> Алгоритм permissions </h2>
    <p>По числу, полученному в аргументе с помощью библиотеки stat, а затем по функциям из неё же, переводим права в буквенный вид.</p>

<h2> Алгоритм input_check </h2>
    <p>Создаём список, в котором 2 пустых списка: для путей(туда же токен функции) и для флагов. Далее парсим по токенам и смотрим на тип токена: путь с кавычками - обрезаем кавычки и кладём в список путей, пробел - скип, флаг - кладём в список флаг, остальное кладём в список путей. Затем убираем повторы у флагов и букв в флагах.</p>

<h2> Алгоритм normalisation_path </h2>
    <p>Переходим в текущую рабочую директорию. Заменяем разделители на /. Если в пути есть попытка перехода в домашний каталог - переходим в него и идём дальше по пути и нормализуем, иначе - просто нормализуем. В конце берём от данного пути абсолютный и возвращаем его.</p>

<h2> Система логирования </h2>
    <p>В файле src/config.py хранится словарь конфигурации логера. Далее в модулях, где нужно логировать, создаётся экземпляр логера. Логи сохраняются в файл debug.log, где хранится столько последних логов, сколько может уместиться в 5 МБ. Если файл debug.log отсутствует, создаётся новый, иначе логи записываются в существующий debug.log.</p>
